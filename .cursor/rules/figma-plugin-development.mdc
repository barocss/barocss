---
description: Figma 플러그인 개발 가이드
globs: 
alwaysApply: false
---
# Figma Plugin Development Guide

## Plugin Structure

### 1. Core File Structure

```
apps/cssma-plugin/
├── src/
│   ├── components/
│   │   ├── CssConverter.tsx      # Main CSS conversion component
│   │   ├── LivePreview.tsx       # Real-time preview system
│   │   └── ui/                   # UI components
│   ├── hooks/
│   │   └── useLocalStorage.ts    # Local storage hook
│   ├── lib/
│   │   └── figma-utils.ts        # Figma API utilities
│   ├── styles/
│   │   └── globals.css           # Global styles
│   ├── code.ts                   # Figma plugin backend
│   └── ui.html                   # Plugin UI entry point
├── manifest.json                 # Plugin manifest
└── package.json
```

### 2. Manifest Configuration

```json
{
  "name": "cssma",
  "id": "your-plugin-id",
  "api": "1.0.0",
  "main": "dist/code.js",
  "ui": "dist/ui.html",
  "capabilities": [],
  "enableProposedApi": false,
  "editorType": ["figma"],
  "networkAccess": {
    "allowedDomains": ["none"]
  }
}
```

## Real-time Preview System

### 1. LivePreview Component ([apps/cssma-plugin/src/components/LivePreview.tsx](mdc:apps/cssma-plugin/src/components/LivePreview.tsx))

Core component for real-time CSS preview functionality:

```typescript
interface LivePreviewProps {
  cssInput: string;
  isEnabled: boolean;
  onToggle: (enabled: boolean) => void;
}

// Key features:
// - Performance optimization with 300ms debouncing
// - Error handling and user-friendly messages
// - Style inspector showing applied styles
// - Settings persistence through local storage
```

#### Core Features

1. **Debouncing Optimization**
```typescript
const debouncedCssInput = useDebounce(cssInput, 300);
```

2. **Error Handling**
```typescript
try {
  const styles = processCssStyles(cssInput);
  setProcessedStyles(styles);
  setError(null);
} catch (err) {
  setError('An error occurred while processing CSS.');
}
```

3. **Style Inspector**
```typescript
const getAppliedStyles = (styles: any) => {
  return Object.entries(styles)
    .filter(([_, value]) => value !== undefined)
    .map(([key, value]) => ({ property: key, value }));
};
```

### 2. CSS Converter Integration ([apps/cssma-plugin/src/components/CssConverter.tsx](mdc:apps/cssma-plugin/src/components/CssConverter.tsx))

```typescript
// LivePreview component integration
<LivePreview
  cssInput={cssInput}
  isEnabled={isLivePreviewEnabled}
  onToggle={setIsLivePreviewEnabled}
/>
```

### 3. Local Storage Hook ([apps/cssma-plugin/src/hooks/useLocalStorage.ts](mdc:apps/cssma-plugin/src/hooks/useLocalStorage.ts))

User settings persistence:

```typescript
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  // Load initial value
  // Update and save value
  // Ensure type safety
}
```

## Figma API Utilization

### 1. Node Manipulation

```typescript
// Get selected nodes
const selection = figma.currentPage.selection;

// Create new node
const frame = figma.createFrame();
frame.name = "Generated Frame";

// Apply styles
frame.layoutMode = "VERTICAL";
frame.fills = [{ type: "SOLID", color: { r: 1, g: 0, b: 0 } }];
```

### 2. Message Communication

#### UI → Plugin (code.ts)
```typescript
// Send message from UI to plugin
parent.postMessage({
  pluginMessage: {
    type: 'apply-styles',
    styles: processedStyles
  }
}, '*');
```

#### Plugin → UI
```typescript
// Send message from plugin to UI
figma.ui.postMessage({
  type: 'selection-changed',
  selection: figma.currentPage.selection.length
});
```

### 3. Style Application Patterns

```typescript
// Safe style application
function applyStyles(node: SceneNode, styles: any) {
  try {
    // Layout properties
    if ('layoutMode' in node && styles.layoutMode) {
      node.layoutMode = styles.layoutMode;
    }
    
    // Fill properties
    if ('fills' in node && styles.fills) {
      node.fills = styles.fills;
    }
    
    // Size properties
    if (styles.width) node.resize(styles.width, node.height);
    if (styles.height) node.resize(node.width, styles.height);
    
  } catch (error) {
    console.error('Style application failed:', error);
  }
}
```

## Performance Optimization

### 1. Debouncing Strategy

```typescript
// 300ms debouncing for user input
const useDebounce = (value: string, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
};
```

### 2. Memoization

```typescript
// Cache style processing results
const processedStyles = useMemo(() => {
  if (!debouncedCssInput.trim()) return null;
  
  try {
    return processCssStyles(debouncedCssInput);
  } catch {
    return null;
  }
}, [debouncedCssInput]);
```

### 3. Conditional Rendering

```typescript
// Render components only when necessary
{isEnabled && processedStyles && (
  <StyleInspector styles={processedStyles} />
)}
```

## Error Handling and User Experience

### 1. Error State Management

```typescript
interface ErrorState {
  message: string;
  type: 'warning' | 'error';
  details?: string;
}

// User-friendly error messages
const getErrorMessage = (error: unknown): string => {
  if (error instanceof SyntaxError) {
    return 'CSS syntax error detected. Please check your input.';
  }
  return 'An error occurred during processing.';
};
```

### 2. Loading States

```typescript
// Loading indicator
{isLoading && (
  <div className="flex items-center gap-2">
    <Spinner size="sm" />
    <span>Processing styles...</span>
  </div>
)}
```

### 3. Empty State Handling

```typescript
// Guidance for empty input
{!cssInput.trim() && (
  <div className="text-gray-500 text-center py-4">
    Please enter Tailwind CSS classes
  </div>
)}
```

## Testing Strategy

### 1. Component Testing

```typescript
// LivePreview component tests
describe('LivePreview', () => {
  it('should debounce CSS input', async () => {
    const { rerender } = render(
      <LivePreview cssInput="flex" isEnabled={true} onToggle={jest.fn()} />
    );
    
    // Debouncing test logic
  });
  
  it('should handle CSS errors gracefully', () => {
    // Error handling tests
  });
});
```

### 2. Integration Testing

```typescript
// Figma API mocking
const mockFigma = {
  createFrame: jest.fn(),
  currentPage: {
    selection: []
  }
};

global.figma = mockFigma;
```

## Deployment and Build

### 1. Build Configuration

```json
{
  "scripts": {
    "build": "webpack --mode=production",
    "dev": "webpack --mode=development --watch",
    "type-check": "tsc --noEmit"
  }
}
```

### 2. Webpack Configuration

```javascript
// webpack.config.js
module.exports = {
  entry: {
    ui: './src/ui.tsx',
    code: './src/code.ts'
  },
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  }
};
```

### 3. Plugin Deployment

1. **Run Build**: `pnpm build`
2. **Verify Manifest**: Validate `manifest.json` configuration
3. **Figma Developer Console**: Upload plugin
4. **Testing**: Verify functionality across various scenarios

## Debugging Guide

### 1. Developer Tools Usage

```typescript
// Console logging
console.log('Current selection:', figma.currentPage.selection);

// Error tracking
try {
  // Risky operations
} catch (error) {
  console.error('Error details:', error);
  figma.notify('An error occurred: ' + error.message);
}
```

### 2. Common Problem Solutions

#### Plugin Not Loading
- Check `manifest.json` paths
- Verify build output file existence
- Enable Figma developer mode

#### Styles Not Applying
- Check node type compatibility
- Verify permissions and lock status
- Check CSS parsing errors

#### Performance Issues
- Adjust debouncing time (currently 300ms)
- Prevent unnecessary re-renders
- Apply memoization

Use this guide to develop efficient and user-friendly Figma plugins.
